package flowmode

import (
	"context"
	"errors"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"path"
	"sync"
	"syscall"

	"github.com/grafana/agent/web/api"
	"github.com/grafana/agent/web/ui"
	"go.opentelemetry.io/otel"
	"golang.org/x/exp/maps"

	"github.com/fatih/color"
	"github.com/go-kit/log/level"
	"github.com/gorilla/mux"
	"github.com/grafana/agent/pkg/config/instrumentation"
	"github.com/grafana/agent/pkg/flow"
	"github.com/grafana/agent/pkg/flow/logging"
	"github.com/grafana/agent/pkg/flow/tracing"
	"github.com/grafana/agent/pkg/river"
	"github.com/grafana/agent/pkg/river/diag"
	"github.com/grafana/agent/pkg/usagestats"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/spf13/cobra"
	"go.opentelemetry.io/contrib/instrumentation/github.com/gorilla/mux/otelmux"

	// Install Components
	_ "github.com/grafana/agent/component/all"
)

func runCommand() *cobra.Command {
	r := &flowRun{
		Server: flowRunServer{
			HTTP: flowRunServerHTTP{
				ListenAddr: "127.0.0.1:12345",
				UIPrefix:   "/",
			},
		},
		Storage: flowRunStorage{
			Path: "data-agent/",
		},
		DisableReporting: false,
	}

	cmd := &cobra.Command{
		Use:   "run [flags] file",
		Short: "Run Grafana Agent Flow",
		Long: `The run subcommand runs Grafana Agent Flow in the foreground until an interrupt
is received.

run must be provided an argument pointing at the River file to use. If the
River file wasn't specified, can't be loaded, or contains errors, run will exit
immediately.

run starts an HTTP server which can be used to debug Grafana Agent Flow or
force it to reload (by sending a GET or POST request to /-/reload). The listen
address can be changed through the --server.http.listen-addr flag.

By default, the HTTP server exposes a debugging UI at /. The path of the
debugging UI can be changed by providing a different value to
--server.http.ui-path-prefix.

Additionally, the HTTP server exposes the following debug endpoints:

  /debug/pprof   Go performance profiling tools

If reloading the config file fails, Grafana Agent Flow will continue running in
its last valid state. Components which failed may be be listed as unhealthy,
depending on the nature of the reload error.
`,
		Args:         cobra.ExactArgs(1),
		SilenceUsage: true,

		RunE: func(cmd *cobra.Command, args []string) error {
			if r.RunConfigPath != "" {
				bb, err := os.ReadFile(r.RunConfigPath)
				if err != nil {
					return fmt.Errorf("reading flags-config-file: %w", err)
				}

				if err := river.Unmarshal(bb, r); err != nil {
					return fmt.Errorf("parsing flags-config-file: %w", err)
				}
			}

			return r.Run(args[0])
		},
	}

	cmd.Flags().
		StringVar(&r.RunConfigPath, "flags-config-file", "", "Optional path to a River file containing values for flags.")
	cmd.Flags().
		StringVar(&r.Server.HTTP.ListenAddr, "server.http.listen-addr", r.Server.HTTP.ListenAddr, "address to listen for HTTP traffic on")
	cmd.Flags().StringVar(&r.Server.HTTP.UIPrefix, "server.http.ui-path-prefix", r.Server.HTTP.UIPrefix, "Prefix to serve the HTTP UI at")
	cmd.Flags().StringVar(&r.Storage.Path, "storage.path", r.Storage.Path, "Base directory where components can store data")
	cmd.Flags().
		BoolVar(&r.DisableReporting, "disable-reporting", r.DisableReporting, "Disable reporting of enabled components to Grafana.")
	return cmd
}

type flowRun struct {
	RunConfigPath string

	Server           flowRunServer  `river:"server,block,optional"`
	Storage          flowRunStorage `river:"storage,block,optional"`
	DisableReporting bool           `river:"disable_reporting,attr,optional"`
}

type flowRunServer struct {
	HTTP flowRunServerHTTP `river:"http,block,optional"`
}

type flowRunServerHTTP struct {
	ListenAddr string `river:"listen_addr,attr,optional"`
	UIPrefix   string `river:"ui_prefix,attr,optional"`
}

type flowRunStorage struct {
	Path string `river:"path,attr,optional"`
}

func (fr *flowRun) Run(configFile string) error {
	var wg sync.WaitGroup
	defer wg.Wait()

	ctx, cancel := interruptContext()
	defer cancel()

	if configFile == "" {
		return fmt.Errorf("file argument not provided")
	}

	logSink, err := logging.WriterSink(os.Stderr, logging.DefaultSinkOptions)
	if err != nil {
		return fmt.Errorf("building logger: %w", err)
	}
	l := logging.New(logSink)

	t, err := tracing.New(tracing.DefaultOptions)
	if err != nil {
		return fmt.Errorf("building tracer: %w", err)
	}

	// Set the global tracer provider to catch global traces, but ideally things
	// use the tracer provider given to them so the appropriate attributes get
	// injected.
	otel.SetTracerProvider(t)

	// Immediately start the tracer.
	go func() {
		err := t.Run(ctx)
		if err != nil {
			level.Error(l).Log("msg", "running tracer returned an error", "err", err)
		}
	}()

	// TODO(rfratto): many of the dependencies we import register global metrics,
	// even when their code isn't being used. To reduce the number of series
	// generated by the agent, we should switch to a custom registry.
	//
	// Before doing this, we need to ensure that anything using the default
	// registry that we want to keep can be given a custom registry so desired
	// metrics are still exposed.
	reg := prometheus.DefaultRegisterer
	reg.MustRegister(newResourcesCollector(l))

	f := flow.New(flow.Options{
		LogSink:        logSink,
		Tracer:         t,
		DataPath:       fr.Storage.Path,
		Reg:            reg,
		HTTPPathPrefix: "/api/v0/component/",
		HTTPListenAddr: fr.Server.HTTP.ListenAddr,
	})

	reload := func() error {
		flowCfg, err := loadFlowFile(configFile)
		defer instrumentation.InstrumentLoad(err == nil)

		if err != nil {
			return fmt.Errorf("reading config file %q: %w", configFile, err)
		}
		if err := f.LoadFile(flowCfg, nil); err != nil {
			return fmt.Errorf("error during the initial gragent load: %w", err)
		}

		return nil
	}

	// Flow controller
	{
		wg.Add(1)
		go func() {
			defer wg.Done()
			f.Run(ctx)
		}()
	}

	// HTTP server
	{
		lis, err := net.Listen("tcp", fr.Server.HTTP.ListenAddr)
		if err != nil {
			return fmt.Errorf("failed to listen on %s: %w", fr.Server.HTTP.ListenAddr, err)
		}

		r := mux.NewRouter()
		r.Use(otelmux.Middleware(
			"grafana-agent",
			otelmux.WithTracerProvider(t),
		))

		r.Handle("/metrics", promhttp.Handler())
		r.PathPrefix("/debug/pprof").Handler(http.DefaultServeMux)
		r.PathPrefix("/api/v0/component/{id}/").Handler(f.ComponentHandler())

		r.HandleFunc("/-/ready", func(w http.ResponseWriter, _ *http.Request) {
			if f.Ready() {
				w.WriteHeader(http.StatusOK)
				fmt.Fprintf(w, "Agent is Ready.\n")
			} else {
				w.WriteHeader(http.StatusServiceUnavailable)
				fmt.Fprint(w, "Config failed to load.\n")
			}
		})

		r.HandleFunc("/-/reload", func(w http.ResponseWriter, _ *http.Request) {
			level.Info(l).Log("msg", "reload requested via /-/reload endpoint")
			defer level.Info(l).Log("msg", "config reloaded")

			err := reload()
			if err != nil {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}
			fmt.Fprintln(w, "config reloaded")
		}).Methods(http.MethodGet, http.MethodPost)

		// Register Routes must be the last
		fa := api.NewFlowAPI(f, r)
		fa.RegisterRoutes(path.Join(fr.Server.HTTP.UIPrefix, "/api/v0/web"), r)

		// NOTE(rfratto): keep this at the bottom of all other routes, otherwise it
		// will take precedence over anything else mapped in uiPrefix.
		ui.RegisterRoutes(fr.Server.HTTP.UIPrefix, r)

		srv := &http.Server{Handler: r}

		wg.Add(1)
		go func() {
			defer wg.Done()
			defer cancel()

			level.Info(l).Log("msg", "now listening for http traffic", "addr", fr.Server.HTTP.ListenAddr)
			if err := srv.Serve(lis); err != nil {
				level.Info(l).Log("msg", "http server closed", "err", err)
			}
		}()

		defer func() { _ = srv.Shutdown(ctx) }()
	}

	// Report usage of enabled components
	if !fr.DisableReporting {
		reporter, err := usagestats.NewReporter(l)
		if err != nil {
			return fmt.Errorf("failed to create reporter: %w", err)
		}
		go func() {
			err := reporter.Start(ctx, getEnabledComponentsFunc(f))
			if err != nil {
				level.Error(l).Log("msg", "failed to start reporter", "err", err)
			}
		}()
	}

	// Perform the initial reload. This is done after starting the HTTP server so
	// that /metric and pprof endpoints are available while the Flow controller
	// is loading.
	if err := reload(); err != nil {
		var diags diag.Diagnostics
		if errors.As(err, &diags) {
			bb, _ := os.ReadFile(configFile)

			p := diag.NewPrinter(diag.PrinterConfig{
				Color:              !color.NoColor,
				ContextLinesBefore: 1,
				ContextLinesAfter:  1,
			})
			_ = p.Fprint(os.Stderr, map[string][]byte{configFile: bb}, diags)

			// Print newline after the diagnostics.
			fmt.Println()

			return fmt.Errorf("could not perform the initial load successfully")
		}

		// Exit if the initial load files
		return err
	}

	reloadSignal := make(chan os.Signal, 1)
	signal.Notify(reloadSignal, syscall.SIGHUP)
	defer signal.Stop(reloadSignal)

	for {
		select {
		case <-ctx.Done():
			return nil
		case <-reloadSignal:
			if err := reload(); err != nil {
				level.Error(l).Log("msg", "failed to reload config", "err", err)
			} else {
				level.Info(l).Log("msg", "config reloaded")
			}
		}
	}
}

// getEnabledComponentsFunc returns a function that gets the current enabled components
func getEnabledComponentsFunc(f *flow.Flow) func() map[string]interface{} {
	return func() map[string]interface{} {
		infos := f.ComponentInfos()
		components := map[string]struct{}{}
		for _, info := range infos {
			components[info.Name] = struct{}{}
		}
		return map[string]interface{}{"enabled-components": maps.Keys(components)}
	}
}

func loadFlowFile(filename string) (*flow.File, error) {
	bb, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	instrumentation.InstrumentConfig(bb)

	return flow.ReadFile(filename, bb)
}

func interruptContext() (context.Context, context.CancelFunc) {
	ctx, cancel := context.WithCancel(context.Background())

	go func() {
		defer cancel()
		sig := make(chan os.Signal, 1)
		signal.Notify(sig, os.Interrupt)
		select {
		case <-sig:
		case <-ctx.Done():
		}
		signal.Stop(sig)

		fmt.Fprintln(os.Stderr, "interrupt received")
	}()

	return ctx, cancel
}
