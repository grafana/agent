package flow

import (
	"fmt"
	"strings"

	"github.com/grafana/agent/component"
	"github.com/grafana/agent/pkg/flow/internal/controller"
	"github.com/grafana/agent/pkg/flow/internal/dag"
)

// GetComponent implements [component.Provider].
func (f *Flow) GetComponent(id component.ID, opts component.InfoOptions) (*component.Info, error) {
	f.loadMut.RLock()
	defer f.loadMut.RUnlock()

	if id.ModuleID != "" {
		mod, ok := f.findModule(id.ModuleID)
		if !ok {
			return nil, fmt.Errorf("component %q does not exist", id)
		}

		// TODO(rfratto): can mod.f be nil here?
		return mod.f.GetComponent(component.ID{LocalID: id.LocalID}, opts)
	}

	graph := f.loader.OriginalGraph()

	node := graph.GetByID(id.LocalID)
	if node == nil {
		return nil, fmt.Errorf("component %q does not exist", id)
	}

	cn, ok := node.(*controller.ComponentNode)
	if !ok {
		return nil, fmt.Errorf("%q is not a component", id)
	}

	return f.getComponentDetail(cn, graph, opts), nil
}

// ListComponents implements [component.Provider].
func (f *Flow) ListComponents(moduleID string, opts component.InfoOptions) ([]*component.Info, error) {
	f.loadMut.RLock()
	defer f.loadMut.RUnlock()

	if moduleID != "" {
		mod, ok := f.findModule(moduleID)
		if !ok {
			return nil, fmt.Errorf("module %q does not exist", moduleID)
		}

		// TODO(rfratto): can mod.f be nil here?
		return mod.f.ListComponents("", opts)
	}

	var (
		components = f.loader.Components()
		graph      = f.loader.OriginalGraph()
	)

	detail := make([]*component.Info, len(components))
	for i, component := range components {
		detail[i] = f.getComponentDetail(component, graph, opts)
	}
	return detail, nil
}

// findModule looks up a module by ID.
func (f *Flow) findModule(moduleID string) (*module, bool) {
	// IDs (both module and component) contain "/" characters to indicate a
	// hierarchy. New levels of hierarchy are created when a component creates a
	// module; the component IDs inside of that module are prepended with the
	// component ID that created it.
	//
	// Module IDs, by default, are set to the same as the creating component ID.
	// For example, if a module.string.example component creates a module, the
	// module ID is also module.string.example. Components generated by that module
	// are then called module.string.example/LOCAL_COMPONENT_ID.
	//
	// However, when a component creates a module, it can request a custom ID.
	// The custom ID is combined with the component ID to create a unique module
	// ID, using the same "/" character as is used to searate modules.
	//
	// Let's say a module.string.example component creates a module with the same
	// name, but then inside of that module, a module.kubernetes.example
	// component creates a module called
	// module.kubernetes.example/kube-system/kube-system-module. Finally, let's
	// say inside of that module, a module.git.kubernetes component creates a
	// module with the same name.
	//
	// This makes the overall hierarchy look like this:
	//
	// - module.string.example
	//   - module.kubernetes.example/kube-system/kube-system-module
	//     - module.git.kubernetes
	//
	// The deepest module in this hierarchy has the very wordy ID of
	// module.string.example/module.kubernetes/kube-system/kube-system-module/module.git.kubernetes.
	//
	// Because the "/" character is used to both separate modules AND to
	// namespace modules from the same component, we need to attempt to do a
	// longest path match to be able to identify whether a / indicates a module
	// hierarchy or a module "namespace."
	//
	// Here, we gradually iterate through the path fragments, iteratively
	// building up module names, and traversing through the tree until we find
	// the final module.

	var (
		currentController = f     // Current controller containing module loader components.
		currentModule     *module // Currently discovered module.

		fragments     = strings.Split(moduleID, "/") // All path fragments.
		fragmentIndex = 0                            // Current path fragment index.

		searchID string // moduleID currently being searched for.
	)

	for fragmentIndex < len(fragments) {
		// Hierarchies always start with a module loader component.
		fragment := fragments[fragmentIndex]
		fragmentIndex++

		// Append the fragment to the module searchID.
		if searchID == "" {
			searchID = fragment
		} else {
			searchID = searchID + "/" + fragment
		}

		node := currentController.loader.OriginalGraph().GetByID(fragment)
		cn, ok := node.(*controller.ComponentNode)
		if !ok {
			return nil, false
		}
		ctrl := cn.ModuleController().(*moduleController)

		// Now we need to search the module loader component for the module,
		// incrementally appending to searchID until we found the module we're
		// looking for.
		//
		// BUG(rfratto): this logic breaks if two modules from the same component
		// have a prefix relationship.
		//
		// For example, if a component creates two modules named:
		//
		// * module.kubernetes.example
		// * module.kubernetes.example/kube-system/kube-system-module
		//
		// Then our loop below will never find the latter.
		//
		// While we could turn this into a longest path search, it increases the
		// complexity of this function from O(N) to O(N*M).
		//
		// One solution could be to force module names to behave similar to
		// component names, which prevent the scenario above (i.e., it is not
		// permitted to define a discovery component because discovery is a namespace
		// of other components).
		//
		// Alternatively, to make _all_ of this simpler, the / character can be
		// reserved and disallowed when a component is creating a module.

		var foundModule bool

		for {
			mod, ok := ctrl.getModule(searchID)
			if ok {
				currentModule = mod
				currentController = mod.f // TODO(rfratto): can this be nil here?
				foundModule = true
				break
			}

			// Optimization: check to see if this component has any namespaced
			// modules. If it doesn't, we're never going to find a match, and we can
			// quit early.
			if !ctrl.hasNonDefaultModule() || fragmentIndex == len(fragments) {
				break
			}

			fragment := fragments[fragmentIndex]
			fragmentIndex++
			searchID = searchID + "/" + fragment
		}

		if !foundModule {
			return nil, false
		}
	}

	return currentModule, currentModule != nil
}

func (f *Flow) getComponentDetail(cn *controller.ComponentNode, graph *dag.Graph, opts component.InfoOptions) *component.Info {
	var references, referencedBy []string

	// Skip over any edge which isn't between two component nodes. This is a
	// temporary workaround needed until there's athe concept of configuration
	// blocks in the API.
	//
	// Without this change, the graph fails to render when a configuration
	// block is referenced in the graph.
	//
	// TODO(rfratto): add support for config block nodes in the API and UI.
	for _, dep := range graph.Dependencies(cn) {
		if _, ok := dep.(*controller.ComponentNode); ok {
			references = append(references, dep.NodeID())
		}
	}
	for _, dep := range graph.Dependants(cn) {
		if _, ok := dep.(*controller.ComponentNode); ok {
			referencedBy = append(referencedBy, dep.NodeID())
		}
	}

	// Fields which are optional to set.
	var (
		health    component.Health
		arguments component.Arguments
		exports   component.Exports
		debugInfo interface{}
	)

	if opts.GetHealth {
		health = cn.CurrentHealth()
	}
	if opts.GetArguments {
		arguments = cn.Arguments()
	}
	if opts.GetExports {
		exports = cn.Exports()
	}
	if opts.GetDebugInfo {
		debugInfo = cn.DebugInfo()
	}

	return &component.Info{
		Component: cn.Component(),
		ModuleIDs: cn.ModuleIDs(),

		ID: component.ID{
			ModuleID: f.opts.ControllerID,
			LocalID:  cn.NodeID(),
		},
		Label: cn.Label(),

		References:   references,
		ReferencedBy: referencedBy,

		Registration: cn.Registration(),
		Health:       health,

		Arguments: arguments,
		Exports:   exports,
		DebugInfo: debugInfo,
	}
}
